<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>DBF Advanced Report Generator</title>

<style>
body {
    font-family: Arial, sans-serif;
    padding: 20px;
}
h2 {
    margin-bottom: 5px;
}
.controls {
    margin: 10px 0;
}
button {
    margin-right: 5px;
}

/* TABLE */
table {
    border-collapse: collapse;
    width: 100%;
    margin-top: 10px;
    table-layout: auto;
}
th, td {
    border: 1px solid #ccc;
    padding: 6px 8px;
    font-size: 13px;
}
td {
    white-space: normal;
}
th {
    background: #f0f0f0;
    white-space: nowrap;
}

/* ALIGNMENT */
.numeric {
    text-align: right;
}

/* ROW TYPES */
.group-header {
    background: #ddd;
    font-weight: bold;
}
.total-row {
    background: #f9f9f9;
    font-weight: bold;
}
.page-total {
    background: #eef6ff;
    font-weight: bold;
    border-top: 2px dashed #666;
}
.grand-total {
    background: #e6e6e6;
    font-weight: bold;
    border-top: 3px solid #000;
}

/* UI */
.pagination {
    margin-top: 10px;
}
.column-box {
    display: inline-block;
    margin-right: 12px;
}
.column-box input[type="text"] {
    width: 100px;
    margin-left: 4px;
}

/* PRINT / PDF */
@media print {
    .ui-controls,
    .pagination {
        display: none !important;
    }
    body {
        padding: 10px;
    }
    h2 {
        margin-top: 0;
    }
}
</style>
</head>

<body>

<h2 contenteditable="true" id="reportTitle">
    DBF Advanced Report Generator
</h2>

<div class="ui-controls">

<input type="file" id="dbfFile" accept=".dbf">

<div class="controls">
    Group by:
    <select id="groupField"></select>

    Rows per page:
    <select id="pageSize">
        <option>25</option>
        <option>50</option>
        <option selected>100</option>
        <option>250</option>
    </select>

    <button onclick="exportCSV()">Export CSV</button>
    <button onclick="window.print()">Export PDF</button>
    <button onclick="saveLayout()">Save Layout</button>
    <input type="file" id="loadLayoutFile" accept=".json" onchange="loadLayout(event)">
</div>

<div class="controls">
    <strong>Columns:</strong>
    <span id="columnSelector"></span>
</div>

</div>

<div id="report"></div>
<div class="pagination" id="pagination"></div>

<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<script>
let headers = [];
let columnAliases = [];
let allRows = [];
let visibleColumns = [];
let currentPage = 1;

/* ---------- HELPERS ---------- */

function excelSerialToDate(v) {
    if (typeof v !== "number") return v;
    if (v < 30000 || v > 60000) return v;
    const d = new Date((v - 25569) * 86400 * 1000);
    return d.toISOString().split("T")[0];
}

function isNumericNonDate(v) {
    return typeof v === "number" && !isNaN(v) && !(v >= 30000 && v <= 60000);
}

function normalizeGroupValue(v) {
    if (typeof v === "number" && v >= 30000 && v <= 60000) {
        return excelSerialToDate(v);
    }
    if (v === null || v === undefined || v === "") {
        return "(blank)";
    }
    return String(v);
}

/* ---------- LOAD DBF ---------- */

document.getElementById("dbfFile").addEventListener("change", async e => {
    const file = e.target.files[0];
    if (!file) return;

    const buffer = await file.arrayBuffer();
    const workbook = XLSX.read(buffer, { type: "array", dense: true });
    const sheet = workbook.Sheets[workbook.SheetNames[0]];

    const rows = XLSX.utils.sheet_to_json(sheet, {
        header: 1,
        defval: "",
        blankrows: false
    });

    headers = rows.shift();
    columnAliases = [...headers];
    allRows = rows;
    visibleColumns = headers.map(() => true);

    populateGroupFields();
    populateColumnSelector();

    currentPage = 1;
    render();
});

/* ---------- UI ---------- */

function populateGroupFields() {
    const sel = document.getElementById("groupField");
    sel.innerHTML = `<option value="">(none)</option>`;
    headers.forEach((_, i) => {
        const o = document.createElement("option");
        o.value = i;
        o.textContent = columnAliases[i];
        sel.appendChild(o);
    });
}

function populateColumnSelector() {
    const c = document.getElementById("columnSelector");
    c.innerHTML = "";

    headers.forEach((_, i) => {
        const box = document.createElement("div");
        box.className = "column-box";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = visibleColumns[i];
        cb.onchange = () => {
            visibleColumns[i] = cb.checked;
            render();
        };

        const input = document.createElement("input");
        input.type = "text";
        input.value = columnAliases[i];
        input.oninput = () => {
            columnAliases[i] = input.value || headers[i];
            populateGroupFields();
            render();
        };

        box.appendChild(cb);
        box.appendChild(input);
        c.appendChild(box);
    });
}

/* ---------- RENDER ---------- */

function render() {
    const groupIndex = document.getElementById("groupField").value;
    const pageSize = parseInt(document.getElementById("pageSize").value);

    let grouped = {};
    let grandTotals = {};

    allRows.forEach(r => {
        r.forEach((v, i) => {
            if (visibleColumns[i] && isNumericNonDate(v)) {
                grandTotals[i] = (grandTotals[i] || 0) + v;
            }
        });
    });

    if (groupIndex !== "") {
        allRows.forEach(r => {
            const key = normalizeGroupValue(r[groupIndex]);
            grouped[key] = grouped[key] || [];
            grouped[key].push(r);
        });
    } else {
        grouped["ALL"] = allRows;
    }

    const flat = [];

    Object.entries(grouped).forEach(([key, rows]) => {
        if (groupIndex !== "") flat.push({ group: key });

        let totals = {};
        rows.forEach(r => {
            flat.push(r);
            r.forEach((v, i) => {
                if (visibleColumns[i] && isNumericNonDate(v)) {
                    totals[i] = (totals[i] || 0) + v;
                }
            });
        });

        if (groupIndex !== "") flat.push({ total: totals });
    });

    flat.push({ grand: grandTotals });

    const totalPages = Math.ceil(flat.length / pageSize);
    const start = (currentPage - 1) * pageSize;
    const pageRows = flat.slice(start, start + pageSize);

    renderTable(pageRows);
    renderPagination(totalPages);
}

/* ---------- TABLE ---------- */

function renderTable(rows) {
    const report = document.getElementById("report");
    report.innerHTML = "";

    const table = document.createElement("table");

    const trh = document.createElement("tr");
    headers.forEach((_, i) => {
        if (!visibleColumns[i]) return;
        const th = document.createElement("th");
        th.textContent = columnAliases[i];
        trh.appendChild(th);
    });
    table.appendChild(trh);

    let pageTotals = {};

    rows.forEach(r => {

        if (r.group) {
            const tr = document.createElement("tr");
            const td = document.createElement("td");
            td.colSpan = visibleColumns.filter(Boolean).length;
            td.textContent = "â–¶ " + r.group;
            td.className = "group-header";
            tr.appendChild(td);
            table.appendChild(tr);
            return;
        }

        if (r.total || r.grand) {
            const tr = document.createElement("tr");
            headers.forEach((_, i) => {
                if (!visibleColumns[i]) return;
                const td = document.createElement("td");
                const val = (r.total || r.grand)[i];
                td.textContent = val ? val.toFixed(2) : "";
                td.className = (r.grand ? "grand-total" : "total-row") + " numeric";
                tr.appendChild(td);
            });
            table.appendChild(tr);
            return;
        }

        const tr = document.createElement("tr");
        r.forEach((v, i) => {
            if (!visibleColumns[i]) return;
            if (isNumericNonDate(v)) {
                pageTotals[i] = (pageTotals[i] || 0) + v;
            }
            const td = document.createElement("td");
            td.textContent = excelSerialToDate(v);
            if (isNumericNonDate(v)) td.classList.add("numeric");
            tr.appendChild(td);
        });
        table.appendChild(tr);
    });

    const ptr = document.createElement("tr");
    headers.forEach((_, i) => {
        if (!visibleColumns[i]) return;
        const td = document.createElement("td");
        td.textContent = pageTotals[i] ? pageTotals[i].toFixed(2) : "";
        td.className = "page-total numeric";
        ptr.appendChild(td);
    });
    table.appendChild(ptr);

    report.appendChild(table);
    autoFitTable(table);
}

/* ---------- PAGINATION ---------- */

function renderPagination(totalPages) {
    const p = document.getElementById("pagination");
    p.innerHTML = "";

    for (let i = 1; i <= totalPages; i++) {
        const b = document.createElement("button");
        b.textContent = i;
        b.disabled = i === currentPage;
        b.onclick = () => {
            currentPage = i;
            render();
        };
        p.appendChild(b);
    }
}

document.getElementById("groupField").onchange = () => {
    currentPage = 1;
    render();
};
document.getElementById("pageSize").onchange = () => {
    currentPage = 1;
    render();
};

/* ---------- EXPORT ---------- */

function exportCSV() {
    let csv = columnAliases
        .filter((_, i) => visibleColumns[i])
        .join(",") + "\n";

    allRows.forEach(r => {
        csv += r
            .filter((_, i) => visibleColumns[i])
            .map(v => `"${excelSerialToDate(v)}"`)
            .join(",") + "\n";
    });

    const blob = new Blob([csv], { type: "text/csv" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "report.csv";
    a.click();
}

/* ---------- SAVE / LOAD LAYOUT ---------- */

function saveLayout() {
    const layout = {
        title: document.getElementById("reportTitle").innerText.trim(),
        columnAliases,
        visibleColumns,
        groupField: document.getElementById("groupField").value,
        pageSize: document.getElementById("pageSize").value
    };

    const blob = new Blob(
        [JSON.stringify(layout, null, 2)],
        { type: "application/json" }
    );

    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "report-layout.json";
    a.click();
}

function loadLayout(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = e => {
        try {
            const layout = JSON.parse(e.target.result);

            if (layout.title)
                document.getElementById("reportTitle").innerText = layout.title;

            if (Array.isArray(layout.columnAliases))
                columnAliases = layout.columnAliases.map((v, i) => v || headers[i]);

            if (Array.isArray(layout.visibleColumns))
                visibleColumns = layout.visibleColumns.slice();

            if (layout.groupField !== undefined)
                document.getElementById("groupField").value = layout.groupField;

            if (layout.pageSize)
                document.getElementById("pageSize").value = layout.pageSize;

            populateGroupFields();
            populateColumnSelector();
            currentPage = 1;
            render();

        } catch {
            alert("Invalid layout file");
        }
    };
    reader.readAsText(file);
}

/* ---------- AUTO FIT ---------- */

function autoFitTable(table) {
    const rows = table.rows;
    if (!rows.length) return;

    const colCount = rows[0].cells.length;
    const colWidths = new Array(colCount).fill(0);

    for (let r = 0; r < rows.length; r++) {
        for (let c = 0; c < colCount; c++) {
            const cell = rows[r].cells[c];
            colWidths[c] = Math.max(colWidths[c], cell.scrollWidth);
        }
    }

    for (let c = 0; c < colCount; c++) {
        for (let r = 0; r < rows.length; r++) {
            rows[r].cells[c].style.width = (colWidths[c] + 12) + "px";
        }
    }
}
</script>

</body>
</html>
